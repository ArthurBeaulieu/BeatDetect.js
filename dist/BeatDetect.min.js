/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/BeatDetect.js":
/*!***************************!*\
  !*** ./src/BeatDetect.js ***!
  \***************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_exports__, __webpack_require__.r, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });



class BeatDetect {


	constructor(options) {
		window.AudioContext = window.AudioContext || window.webkitAudioContext;
		window.OfflineContext = window.OfflineAudioContext || window.webkitOfflineAudioContext;

		this._sampleRate = options.sampleRate || 44100;
		this._log = options.log || false;
		this._perf = options.perf || false;
	}


	getBeatInfo(options) {
		const perf = { // Performances mark to compute execution duration
			m0: performance.now(), // Start beat detection
			m1: 0, // Fetch track done
			m2: 0, // Offline context rendered
			m3: 0 // Bpm processing done
		};

		options.perf = perf;
		return new Promise((resolve, reject) => {
			this._fetchRawTrack(options)
				.then(this._buildOfflineCtx.bind(this))
				.then(this._processRenderedBuffer.bind(this))
				.then(resolve).catch(reject);
		});
	}


	_fetchRawTrack(options) {
		this._logEvent('log', 'Fetch track');
		return new Promise((resolve, reject) => {
	    let request = new XMLHttpRequest();
	    request.open('GET', options.url, true);
	    request.responseType = 'arraybuffer';
	    request.onload = () => {
	    	options.perf.m1 = performance.now();
	    	resolve(Object.assign(request, options));
	    };
	    request.send();
		});
	}


	_buildOfflineCtx(options) {
		this._logEvent('log', 'Offline rendering');
		return new Promise((resolve, reject) => {
			const audioCtx = new AudioContext();
      // Create offline context
      audioCtx.decodeAudioData(options.response, function(buffer) {
        var offlineCtx = new OfflineContext(2, buffer.duration * this._sampleRate, this._sampleRate);
				// Create buffer source
        var source = offlineCtx.createBufferSource();
        source.buffer = buffer;

        // Beats, or kicks, generally occur around the 100 to 150 hz range.
        // Below this is often the bassline.  So let's focus just on that.

        // First a lowpass to remove most of the song.

        var lowpass = offlineCtx.createBiquadFilter();
        lowpass.type = "lowpass";
        lowpass.frequency.value = 150;
        lowpass.Q.value = 1;

        // Run the output of the source through the low pass.

        source.connect(lowpass);

        // Now a highpass to remove the bassline.

        var highpass = offlineCtx.createBiquadFilter();
        highpass.type = "highpass";
        highpass.frequency.value = 100;
        highpass.Q.value = 1;

        // Run the output of the lowpass through the highpass.

        lowpass.connect(highpass);

        // Run the output of the highpass through our offline context.

        highpass.connect(offlineCtx.destination);

        // Start the source, and render the output into the offline conext.

        source.start(0);
        offlineCtx.startRendering();

			  offlineCtx.oncomplete = result => {
			  	options.perf.m2 = performance.now();
			    resolve(Object.assign(result, options));
			  };
      }.bind(this));
		});
	}


	_processRenderedBuffer(options) {
		this._logEvent('log', 'Collect info');
		return new Promise(resolve => {
		  const filteredBuffer = options.renderedBuffer;
	    const leftData = filteredBuffer.getChannelData(0);
	    const rightData = filteredBuffer.getChannelData(1);		
		  const peaks = this._getPeaks([leftData, rightData], filteredBuffer);
		  var groups = this._getIntervals(peaks);
		  // Sort possible bpms by count to get the most accurate one in first position
		  var top = groups.sort(function(intA, intB) {
	      return intB.count - intA.count;
	    }).splice(0, 5);

			this._logEvent('log', 'Analysis done');
			options.perf.m3 = performance.now();
			const perf = this._getPerfDuraction(options.perf);
		  resolve(Object.assign({
		  	bpm: top[0].tempo,
		  	offset: this._getTimeOffset(peaks[0], leftData.length, top[0].tempo)
		  }, this._perf ? {
		  	perf: perf
		  } : null));
		});
	}


	/* BPM guess methods */


	_getPeaks(data, buffer) {
		  // What we're going to do here, is to divide up our audio into parts.

		  // We will then identify, for each part, what the loudest sample is in that
		  // part.

		  // It's implied that that sample would represent the most likely 'beat'
		  // within that part.

		  // Each part is 0.5 seconds long - or 22,050 samples.

		  // This will allow us to ignore breaks, and allow us to address tracks with
		  // a BPM below 120.

		  var partSize = this._sampleRate / 2,
		      parts = data[0].length / partSize,
		      peaks = [];

		  for (var i = 0; i < parts; i++) {
		    var max = 0;
		    for (var j = i * partSize; j < (i + 1) * partSize; j++) {
		      var volume = Math.max(Math.abs(data[0][j]), Math.abs(data[1][j]));
		      if (!max || (volume > max.volume)) {
		        max = {
		          position: j,
		          volume: volume,
		          t: j / this._sampleRate
		        };
		      }
		    }
		    peaks.push(max);
		  }

		  // We then sort the peaks according to volume...

		  peaks.sort(function(a, b) {
		    return b.volume - a.volume;
		  });

		  // ...take the loundest half of those...

		  peaks = peaks.splice(0, peaks.length * 0.5);

		  // ...and re-sort it back based on position.

		  peaks.sort(function(a, b) {
		    return a.position - b.position;
		  });

		  return peaks;
	}


	_getIntervals(peaks) {

	  // What we now do is get all of our peaks, and then measure the distance to
	  // other peaks, to create intervals.  Then based on the distance between
	  // those peaks (the distance of the intervals) we can calculate the BPM of
	  // that particular interval.

	  // The interval that is seen the most should have the BPM that corresponds
	  // to the track itself.

	  var groups = [];

	  peaks.forEach((peak, index) => {
	    for (var i = 1; (index + i) < peaks.length && i < 10; i++) {
	      var group = {
	        tempo: (60 * this._sampleRate) / (peaks[index + i].position - peak.position),
	        count: 1
	      };

	      while (group.tempo < 80) {
	        group.tempo *= 2;
	      }

	      while (group.tempo > 160) {
	        group.tempo /= 2;
	      }

	      //group.tempo = Math.round(group.tempo);

	      if (!(groups.some(function(interval) {
	        return (interval.tempo === group.tempo ? interval.count++ : 0);
	      }))) {
	        groups.push(group);
	      }
	    }
	  });
	  return groups;
	}


	_getTimeOffset(peak, length, bpm) {
		// Here we compute beat time offset using the first spotted peak.
		// Using its sample index and the found bpm
		const bpmTime = 60 / bpm;
		const firstBeatTime = peak.position / this._sampleRate;
		let offset = firstBeatTime;

		while (offset >= bpmTime) {
			offset -= bpmTime;
		}

		return offset;
	}


	_getPerfDuraction(perf) {
		// Convert performance mark into ellapsed seconds
		return {
			total: (perf.m3 - perf.m0) / 1000,
			fetch: (perf.m1 - perf.m0) / 1000,
			render: (perf.m2 - perf.m1) / 1000,
			process: (perf.m3 - perf.m2) / 1000
		}
	}


	/* utils */


	_logEvent(level, string) {
		if (this._log === true) {
			console[level](`BeatDetect : ${string}`);
		}
	}


  _floatRound(value, precision) {
    const multiplier = Math.pow(10, precision || 0);
    return Math.round(value * multiplier) / multiplier;
  }


}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BeatDetect);

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/BeatDetect.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;