/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/BeatDetect.js":
/*!***************************!*\
  !*** ./src/BeatDetect.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar BeatDetect = /*#__PURE__*/function () {\n  /** @summary <h1>Beat detection library</h1>\n   * @author Arthur Beaulieu\n   * @since November 2020\n   * @description <blockquote>This library provides an audio analyser to retrieve a track beat per minute value. It is\n   * also made to guess the time offset before the first significant sound (relative to the BPM), and the time offset of\n   * the estimated first bar. All its parameters can be updated when constructed, so it can adapt to any type of audio\n   * input. The analysis method is based on the work of Joe Sullivan and José M. Pérez, and is describe in the\n   * <code>README.md</code> file of its repository. Remarks and pull requests are welcome!</blockquote>\n   * @param {object} [options] - The configuration object of this library\n   * @param {boolean} [options.log=false] - Log debug information during the analysis process\n   * @param {boolean} [options.perf=false] - Log ellapsed time of each analysis step\n   * @param {number} [options.sampleRate=44100] - The sample rate to use during the audio analysis. Can be changed its setter\n   * @param {boolean} [options.round=false] - Allow the output rounding to remove floating point\n   * @param {number} [options.float=8] - The floating precision for the output. Disabled if round is at true\n   * @param {number} [options.lowPassFreq=150] - The low pass filter cut frequency\n   * @param {number} [options.highPassFreq=100] - The high pass filter cut frequency\n   * @param {number[]} [options.bpmRange=[90, 180]] - The BPM range to output the result in\n   * @param {number} [options.timeSignature=4] - The analysed audio time signature **/\n  function BeatDetect() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, BeatDetect);\n\n    // Attach Web Audio API components to the window\n    window.AudioContext = window.AudioContext || window.webkitAudioContext;\n    window.OfflineContext = window.OfflineAudioContext || window.webkitOfflineAudioContext; // Ensure that client browser supports the Web Audio API, return otherwise\n\n    if (!window.AudioContext || !window.OfflineContext) {\n      console.error(\"BeatDetect.ERROR : Your browser doesn't support the WebAudio API.\");\n      return; // Stop right here the BeatDetect.js component construction\n    }\n    /** @public\n     * @member {string} - The BeatDetect version number **/\n\n\n    this.VERSION = '1.0.0';\n    /** @private\n     * @member {boolean} - Log debug information in the console when set to true **/\n\n    this._log = options.log || false;\n    /*  ----  Automation beat deterination internals  ----  */\n\n    /** @private\n     * @member {boolean} - Log elapsed times during the analysis in the console when set to true **/\n\n    this._perf = options.perf || false;\n    /** @private\n     * @member {number} - The sample rate used for analysis. Must match the analysed audio sample rate **/\n\n    this._sampleRate = options.sampleRate || 44100;\n    /** @private\n     * @member {boolean} - Remove any floating point from output when set to true **/\n\n    this._round = options.round || false;\n    /** @private\n     * @member {number} - The number of floating point for the output **/\n\n    this._float = options[\"float\"] || 8;\n    /** @private\n     * @member {number} - The low pass filter cut frequency **/\n\n    this._lowPassFreq = options.lowPassFreq || 150;\n    /** @private\n     * @member {number} - The high pass filter cut frequency **/\n\n    this._highPassFreq = options.highPassFreq || 100;\n    /** @private\n     * @member {array} - The BPM range to display the output in **/\n\n    this._bpmRange = options.bpmRange || [90, 180];\n    /** @private\n     * @member {number} - The studied track time signature **/\n\n    this._timeSignature = options.timeSignature || 4;\n    /*  ------  Manual beat deterination internals  ------  */\n\n    /** @private\n     * @member {number} - The amount of time a click is trigerred to compute BPM **/\n\n    this.count = 0;\n    /** @private\n     * @member {object} - Contains timestamp used to determine manual BPM **/\n\n    this._ts = {\n      current: 0,\n      previous: 0,\n      first: 0\n    };\n    /** @private\n     * @member {number} - Reset tap timeout ID **/\n\n    this._tapResetId = -1;\n  }\n  /*  --------------------------------------------------------------------------------------------------------------- */\n\n  /*  ---------------------------------------------  PUBLIC METHOD  ------------------------------------------------  */\n\n  /*  --------------------------------------------------------------------------------------------------------------- */\n\n  /** @method\n   * @name getBeatInfo\n   * @public\n   * @memberof BeatDetect\n   * @description <blockquote>Perform a beat detection on a given track and return the analysis result trhough the\n   * Promise resolution. Any exception will be thrown in the Promise catch method.</blockquote>\n   * @param {object} options - The beat detection option\n   * @param {string} options.url - The url to the audio file to analyse\n   * @param {string} [options.name] - The track name, only useful for logging\n   * @returns {promise} A Promise that is resolved when analysis is done, of will be rejected otherwise **/\n\n\n  _createClass(BeatDetect, [{\n    key: \"getBeatInfo\",\n    value: function getBeatInfo(options) {\n      var _this = this;\n\n      // Performances mark to compute execution duration\n      options.perf = {\n        m0: performance.now(),\n        // Start beat detection\n        m1: 0,\n        // Fetch track done\n        m2: 0,\n        // Offline context rendered\n        m3: 0 // Bpm processing done\n\n      }; // In order ; fetch track, decode its buffer, process it and send back BPM info\n\n      return new Promise(function (resolve, reject) {\n        _this._fetchRawTrack(options).then(_this._buildOfflineCtx.bind(_this)).then(_this._processRenderedBuffer.bind(_this)).then(resolve)[\"catch\"](reject);\n      });\n    }\n    /*  --------------------------------------------------------------------------------------------------------------- */\n\n    /*  ----------------------------------------  OVERALL LOGIC METHODS  ---------------------------------------------  */\n\n    /*  --------------------------------------------------------------------------------------------------------------- */\n\n    /** @method\n     * @name _fetchRawTrack\n     * @private\n     * @memberof BeatDetect\n     * @description <blockquote>This method will perform a fetch on the given URL to retrieve the track to analyse.</blockquote>\n     * @param {object} options - The option object sent to the <code>getBeatInfo</code> method, augmented with performance marks\n     * @returns {promise} A Promise that is resolved when analysis is done, of will be rejected otherwise **/\n\n  }, {\n    key: \"_fetchRawTrack\",\n    value: function _fetchRawTrack(options) {\n      // TODO use fetch api instead, ES rules\n      this._logEvent('log', \"Fetch track \".concat(options.name || ''));\n\n      return new Promise(function (resolve, reject) {\n        var request = new XMLHttpRequest();\n        request.open('GET', options.url, true);\n        request.responseType = 'arraybuffer';\n\n        request.onload = function () {\n          if (request.status == 404) {\n            reject('BeatDetect.ERROR : 404 File not found.');\n          }\n\n          options.perf.m1 = performance.now();\n          resolve(Object.assign(request, options));\n        };\n\n        request.onerror = reject;\n        request.send();\n      });\n    }\n    /** @method\n     * @name _buildOfflineCtx\n     * @private\n     * @memberof BeatDetect\n     * @description <blockquote>This method will build and connect all required nodes to perform the BPM analysis.</blockquote>\n     * @param {object} options - The option object sent to the <code>_fetchRawTrack</code> method, augmented with track array buffer\n     * @returns {promise} A Promise that is resolved when analysis is done, of will be rejected otherwise **/\n\n  }, {\n    key: \"_buildOfflineCtx\",\n    value: function _buildOfflineCtx(options) {\n      var _this2 = this;\n\n      this._logEvent('log', 'Offline rendering of the track');\n\n      return new Promise(function (resolve, reject) {\n        // Decode track audio with audio context to later feed the offline context with a buffer\n        var audioCtx = new AudioContext();\n        audioCtx.decodeAudioData(options.response, function (buffer) {\n          // Define offline context according to the buffer sample rate and duration\n          var offlineCtx = new window.OfflineContext(2, buffer.duration * _this2._sampleRate, _this2._sampleRate); // Create buffer source from loaded track\n\n          var source = offlineCtx.createBufferSource();\n          source.buffer = buffer; // Lowpass filter to ignore most frequencies except bass (goal is to retrieve kick impulsions)\n\n          var lowpass = offlineCtx.createBiquadFilter();\n          lowpass.type = 'lowpass';\n          lowpass.frequency.value = _this2._lowPassFreq;\n          lowpass.Q.value = 1; // Apply a high pass filter to remove the bassline\n\n          var highpass = offlineCtx.createBiquadFilter();\n          highpass.type = 'highpass';\n          highpass.frequency.value = _this2._highPassFreq;\n          highpass.Q.value = 1; // Chain offline nodes from source to destination with filters among\n\n          source.connect(lowpass);\n          lowpass.connect(highpass);\n          highpass.connect(offlineCtx.destination); // Start the source and rendering\n\n          source.start(0);\n          offlineCtx.startRendering(); // Continnue analysis when buffer has been read\n\n          offlineCtx.oncomplete = function (result) {\n            options.perf.m2 = performance.now();\n            resolve(Object.assign(result, options));\n          };\n\n          offlineCtx.onerror = reject;\n        }, function (err) {\n          reject(\"BeatDetect.ERROR : \".concat(err));\n        });\n      });\n    }\n    /** @method\n     * @name _processRenderedBuffer\n     * @private\n     * @memberof BeatDetect\n     * @description <blockquote>This method will process the audio buffer to extract its peak and guess the track BPM and offset.</blockquote>\n     * @param {object} options - The option object sent to the <code>_buildOfflineCtx</code> method, augmented with track audio buffer\n     * @returns {promise} A Promise that is resolved when analysis is done, of will be rejected otherwise **/\n\n  }, {\n    key: \"_processRenderedBuffer\",\n    value: function _processRenderedBuffer(options) {\n      var _this3 = this;\n\n      this._logEvent('log', 'Collect beat info');\n\n      return new Promise(function (resolve) {\n        // Extract PCM data from offline rendered buffer\n        var dataL = options.renderedBuffer.getChannelData(0);\n        var dataR = options.renderedBuffer.getChannelData(1); // Extract most intense peaks, and create intervals between them\n\n        var peaks = _this3._getPeaks([dataL, dataR]);\n\n        var groups = _this3._getIntervals(peaks); // Sort found intervals by count to get the most accurate one in first position\n\n\n        var top = groups.sort(function (intA, intB) {\n          return intB.count - intA.count;\n        }).splice(0, 5); // Only keep the 5 best matches\n        // Build offset and first bar\n\n        var offsets = _this3._getOffsets(dataL, top[0].tempo);\n\n        options.perf.m3 = performance.now();\n\n        _this3._logEvent('log', 'Analysis done'); // Sent BPM info to the caller\n\n\n        resolve(Object.assign({\n          bpm: top[0].tempo,\n          offset: _this3._floatRound(offsets.offset, _this3._float),\n          firstBar: _this3._floatRound(offsets.firstBar, _this3._float)\n        }, _this3._perf ? {\n          // Assign perf key to return object if user requested it\n          perf: _this3._getPerfDuration(options.perf)\n        } : null));\n      });\n    }\n    /*  --------------------------------------------------------------------------------------------------------------- */\n\n    /*  ------------------------------------------  BPM GUESS METHODS  -----------------------------------------------  */\n\n    /*  --------------------------------------------------------------------------------------------------------------- */\n\n    /** @method\n      * @name _getPeaks\n      * @private\n      * @memberof BeatDetect\n      * @description <blockquote>This method will extract peak value from given channel data. See implementation for further details.</blockquote>\n      * @param {array[]} data - Array containg L/R audio data arrays\n      * @returns {array} An array filled with peaks value **/\n\n  }, {\n    key: \"_getPeaks\",\n    value: function _getPeaks(data) {\n      // What we're going to do here, is to divide up our audio into parts.\n      // We will then identify, for each part, what the loudest sample is in that part.\n      // It's implied that that sample would represent the most likely 'beat' within that part.\n      // Each part 22,050 samples, half fft.\n      var partSize = this._sampleRate / 2;\n      var parts = data[0].length / partSize;\n      var peaks = []; // Iterate over .5s parts we created\n\n      for (var i = 0; i < parts; ++i) {\n        var max = 0; // Iterate each byte in the studied part\n\n        for (var j = i * partSize; j < (i + 1) * partSize; ++j) {\n          var volume = Math.max(Math.abs(data[0][j]), Math.abs(data[1][j]));\n\n          if (!max || volume > max.volume) {\n            // Save peak at its most intense position\n            max = {\n              position: j,\n              volume: volume\n            };\n          }\n        }\n\n        peaks.push(max);\n      } // Sort peaks per volume\n\n\n      peaks.sort(function (a, b) {\n        return b.volume - a.volume;\n      }); // This way we can ignore the less loud half\n\n      peaks = peaks.splice(0, peaks.length * 0.5); // Then sort again by position to retrieve the playback order\n\n      peaks.sort(function (a, b) {\n        return a.position - b.position;\n      }); // Send back peaks\n\n      return peaks;\n    }\n    /** @method\n      * @name _getIntervals\n      * @private\n      * @memberof BeatDetect\n      * @description <blockquote>This method will then compute time interval between peak, in order to\n     * spot the interval that is the most represented. See implementation for further details.</blockquote>\n      * @param {object[]} peaks - The peaks for a given track. Returned from _getPeaks method\n      * @returns {array} An array of time intervals **/\n\n  }, {\n    key: \"_getIntervals\",\n    value: function _getIntervals(peaks) {\n      var _this4 = this;\n\n      // What we now do is get all of our peaks, and then measure the distance to\n      // other peaks, to create intervals. Then, based on the distance between\n      // those peaks (the distance of the intervals) we can calculate the BPM of\n      // that particular interval.\n      // The interval that is seen the most should have the BPM that corresponds\n      // to the track itself.\n      var groups = []; // Comparing each peak with the next one to compute an interval group\n\n      peaks.forEach(function (peak, index) {\n        var _loop = function _loop(i) {\n          var group = {\n            tempo: 60 * _this4._sampleRate / (peaks[index + i].position - peak.position),\n            count: 1,\n            position: peak.position,\n            peaks: []\n          }; // Trim to fit tempo range to lower bound\n\n          while (group.tempo <= _this4._bpmRange[0]) {\n            group.tempo *= 2;\n          } // Trim to fit tempo range to upper bound\n\n\n          while (group.tempo > _this4._bpmRange[1]) {\n            group.tempo /= 2;\n          } // Integer or floating rounding of tempo value\n\n\n          if (_this4._round === true) {\n            // Integer rounding\n            group.tempo = Math.round(group.tempo);\n          } else {\n            // Floating rounding\n            group.tempo = _this4._floatRound(group.tempo, _this4._float);\n          } // Test if exists and if so, increment the interval count number\n\n\n          var exists = groups.some(function (interval) {\n            if (interval.tempo === group.tempo) {\n              interval.peaks.push(peak);\n              ++interval.count; // Notify that group already exists\n\n              return true;\n            } // Return false if no match\n\n\n            return false;\n          }); // Insert only if not existing\n\n          if (!exists) {\n            groups.push(group);\n          }\n        };\n\n        for (var i = 1; index + i < peaks.length && i < 10; ++i) {\n          _loop(i);\n        }\n      });\n      return groups;\n    }\n    /** @method\n      * @name _getOffsets\n      * @private\n      * @memberof BeatDetect\n      * @description <blockquote>This method will finally compute time offset from song start to first bar, or first\n     * significant beat. See implementation for further details.</blockquote>\n      * @param {object[]} data - Array containg L audio data (no important to stereo this)\n      * @param {number} bpm - The most credible BPM, computed after the most frequent time interval\n      * @returns {object} The beat offset and the offset to the first bar **/\n\n  }, {\n    key: \"_getOffsets\",\n    value: function _getOffsets(data, bpm) {\n      // Now we have bpm, we re-calculate peaks for the 30 first seconds.\n      // Since a peak is at the maximum waveform height, we need to offset its time a little on its left.\n      // This offset is empiric, and based on a fraction of the BPM duration in time.\n      // We assume the left offset from the highest volule value is 5% of the bpm time frame\n      // Once peak are found and sorted, we get offset by taking the most intense peak (which is\n      // a strong time of the time signature), and use its position to find the smallest time from\n      // the track start that is relative to the time signature and the strong time found.\n      // The first bar is the actual first beat that overcome a 20% threshold, it will mostly be\n      // equal to the BPM offset.\n      var partSize = this._sampleRate / 2;\n      var parts = data.length / partSize;\n      var peaks = []; // Create peak with little offset on the left to get the very start of the peak\n\n      for (var _i = 0; _i < parts; ++_i) {\n        var max = 0;\n\n        for (var j = _i * partSize; j < (_i + 1) * partSize; ++j) {\n          var volume = data[j];\n\n          if (!max || volume > max.volume) {\n            max = {\n              position: j - Math.round(60 / bpm * 0.05 * this._sampleRate),\n              // Arbitrary offset on the left of the peak about 5% bpm time\n              volume: volume\n            };\n          }\n        }\n\n        peaks.push(max);\n      } // Saved peaks ordered by position before any sort manipuplation\n\n\n      var unsortedPeaks = [].concat(peaks); // Clone array before sorting for first beat matching\n      // Sort peak per decreasing volumes\n\n      peaks.sort(function (a, b) {\n        return b.volume - a.volume;\n      }); // First peak is the loudest, we assume it is a strong time of the 4/4 time signature\n\n      var refOffset = this._getLowestTimeOffset(peaks[0].position, bpm);\n\n      var mean = 0;\n      var divider = 0; // Find shortest offset\n\n      for (var _i2 = 0; _i2 < peaks.length; ++_i2) {\n        var offset = this._getLowestTimeOffset(peaks[_i2].position, bpm);\n\n        if (offset - refOffset < 0.05 || refOffset - offset > -0.05) {\n          // Only keep first times to compute mean\n          mean += offset;\n          ++divider;\n        }\n      } // Find first beat offset\n\n\n      var i = 0; // Try finding the first peak index that is louder than provided threshold (0.02)\n\n      while (unsortedPeaks[i].volume < 0.02) {\n        // Threshold is also arbitrary...\n        ++i;\n      } // Convert position into time\n\n\n      var firstBar = unsortedPeaks[i].position / this._sampleRate; // If matching first bar is before any possible time ellapsed, we set it at computed offset\n\n      if (firstBar > mean / divider && firstBar < 60 / bpm) {\n        firstBar = mean / divider;\n      } // Return both offset and first bar offset\n\n\n      return {\n        offset: mean / divider,\n        firstBar: firstBar\n      };\n    }\n    /** @method\n      * @name _getLowestTimeOffset\n      * @private\n      * @memberof BeatDetect\n      * @description <blockquote>This method will search for the smallest time in track for a beat ; using\n     * the estimated bpm, we rewind from time signature to get the closest from the track beginning.\n     * See implementation for further details.</blockquote>\n      * @param {object[]} position - The beat position for beat to lower\n      * @param {number} bpm - The most credible BPM, computed after the most frequent time interval\n      * @returns {object} The beat offset and the offset to the first bar **/\n\n  }, {\n    key: \"_getLowestTimeOffset\",\n    value: function _getLowestTimeOffset(position, bpm) {\n      // Here we compute beat time offset using the first spotted peak.\n      // The lowest means we rewind following the time signature, to find the smallest time\n      // which is between 0s and the full mesure time (timesignature * tempo)\n      // Using its sample index and the found bpm\n      var bpmTime = 60 / bpm;\n      var firstBeatTime = position / this._sampleRate;\n      var offset = firstBeatTime;\n\n      while (offset >= bpmTime) {\n        offset -= bpmTime * this._timeSignature;\n      }\n\n      if (offset < 0) {\n        while (offset < 0) {\n          offset += bpmTime;\n        }\n      }\n\n      return offset;\n    }\n    /** @method\n      * @name _getPerfDuration\n      * @private\n      * @memberof BeatDetect\n      * @description <blockquote>This method will format performance mark to be readable as times</blockquote>\n      * @param {object[]} perf - The performance mark to format\n      * @returns {object} The ellapsed times for different beat detection steps **/\n\n  }, {\n    key: \"_getPerfDuration\",\n    value: function _getPerfDuration(perf) {\n      // Convert performance mark into ellapsed seconds\n      return {\n        total: (perf.m3 - perf.m0) / 1000,\n        fetch: (perf.m1 - perf.m0) / 1000,\n        render: (perf.m2 - perf.m1) / 1000,\n        process: (perf.m3 - perf.m2) / 1000\n      };\n    }\n    /*  --------------------------------------------------------------------------------------------------------------- */\n\n    /*  -------------------------------------------  BPM TAP METHODS  ------------------------------------------------  */\n\n    /*  --------------------------------------------------------------------------------------------------------------- */\n\n    /** @method\n      * @name tapBpm\n      * @public\n      * @memberof BeatDetect\n      * @description <blockquote>Providing a DOM element and a callback to manually determine a bpm, using a click.\n     * After 5 seconds, the result will be reset.</blockquote>\n      * @param {objects} options - Manual bpm determinitation options\n      * @param {object} options.element - The DOM element to listen to\n      * @param {number} options.precision - The floating point for result\n      * @param {function} options.callback - The callback function to call each click **/\n\n  }, {\n    key: \"tapBpm\",\n    value: function tapBpm(options) {\n      options.element.addEventListener('click', this._tapBpm.bind(this, options), false);\n    }\n    /** @method\n      * @name _tapBpm\n      * @private\n      * @memberof BeatDetect\n      * @description <blockquote>Internal method to determine manual BPM</blockquote>\n      * @param {object} options - The internal options object\n      * @param {number} precision - The floating point for result\n      * @param {function} callback - The callback function to call each click **/\n\n  }, {\n    key: \"_tapBpm\",\n    value: function _tapBpm(options) {\n      var _this5 = this;\n\n      window.clearTimeout(this._tapResetId);\n      this._ts.current = Date.now(); // Store the first timestamp of the tap sequence on first click\n\n      if (this._ts.first === 0) {\n        this._ts.first = this._ts.current;\n      }\n\n      if (this._ts.previous !== 0) {\n        var bpm = 60000 * this.count / (this._ts.current - this._ts.first);\n\n        if (options.precision) {\n          bpm = this._floatRound(bpm, options.precision);\n        }\n\n        options.callback(bpm);\n      } // Store the old timestamp\n\n\n      this._ts.previous = this._ts.current;\n      ++this.count;\n      this._tapResetId = window.setTimeout(function () {\n        _this5.count = 0;\n        _this5._ts.current = 0;\n        _this5._ts.previous = 0;\n        _this5._ts.first = 0;\n        options.callback('--');\n      }, 5000);\n    }\n    /*  --------------------------------------------------------------------------------------------------------------- */\n\n    /*  --------------------------------------------  UTIL METHODS  --------------------------------------------------  */\n\n    /*  --------------------------------------------------------------------------------------------------------------- */\n\n    /** @method\n     * @name _logEvent\n     * @private\n     * @memberof BeatDetect\n     * @description <blockquote>This method will display a given console output if the logging is allowed.</blockquote>\n     * @param {string} level - The console method to call in info, log, warn, error, trace etc.\n     * @param {string} string - The text to display in the console **/\n\n  }, {\n    key: \"_logEvent\",\n    value: function _logEvent(level, string) {\n      if (this._log === true) {\n        console[level](\"BeatDetect : \".concat(string));\n      }\n    }\n    /** @method\n     * @name _floatRound\n     * @private\n     * @memberof BeatDetect\n     * @description <blockquote>This method will return a rounded floating value to a given precision.</blockquote>\n     * @param {number} value - The value to round at a given floating point\n     * @param {number} precision - The amount of numbers after the floating point\n     * @returns {number} The rounded value with its given floating point **/\n\n  }, {\n    key: \"_floatRound\",\n    value: function _floatRound(value, precision) {\n      var multiplier = Math.pow(10, precision || 0);\n      return Math.round(value * multiplier) / multiplier;\n    }\n    /*  --------------------------------------------------------------------------------------------------------------- */\n\n    /*  --------------------------------------------  SETTERS METHODS  -----------------------------------------------  */\n\n    /*  --------------------------------------------------------------------------------------------------------------- */\n\n    /** Set sample rate for analysis.\n     * @param {number} sampleRate\t**/\n\n  }, {\n    key: \"sampleRate\",\n    set: function set(sampleRate) {\n      this._sampleRate = sampleRate;\n    }\n    /** Set logging in console.\n     * @param {boolean} log\t**/\n\n  }, {\n    key: \"log\",\n    set: function set(log) {\n      this._log = log;\n    }\n    /** Set performance timings in console.\n     * @param {boolean} perf\t**/\n\n  }, {\n    key: \"perf\",\n    set: function set(perf) {\n      this._perf = perf;\n    }\n    /** Set output rounding.\n     * @param {boolean} round\t**/\n\n  }, {\n    key: \"round\",\n    set: function set(round) {\n      this._round = round;\n    }\n    /** Set the output floating precision.\n     * @param {number} round\t**/\n\n  }, {\n    key: \"float\",\n    set: function set(_float) {\n      this._float = _float;\n    }\n    /** Set the low pass filter cut frequency.\n     * @param {number} round\t**/\n\n  }, {\n    key: \"lowPassFreq\",\n    set: function set(lowPassFreq) {\n      this._lowPassFreq = lowPassFreq;\n    }\n    /** Set the high pass filter cut frequency.\n     * @param {number} round\t**/\n\n  }, {\n    key: \"highPassFreq\",\n    set: function set(highPassFreq) {\n      this._highPassFreq = highPassFreq;\n    }\n  }]);\n\n  return BeatDetect;\n}();\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BeatDetect);\n\n//# sourceURL=webpack://BeatDetect/./src/BeatDetect.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/BeatDetect.js"](0, __webpack_exports__, __webpack_require__);
/******/ 	window.BeatDetect = __webpack_exports__.default;
/******/ 	
/******/ })()
;